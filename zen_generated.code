<GENERATED-CODE>
[Step-by-step instructions for the coding agent]
1. Create new file scripts/container-runtime.mjs implementing the ContainerRuntime class:
   - Auto-detects docker/podman availability
   - Detects compose tool variants (docker compose vs docker-compose, podman-compose vs podman compose)
   - Determines sudo requirements (docker daemon access test, podman rootless)
   - Caches detection results
   - Provides exec(command, options) that builds the correct command line and applies sudo if needed
   - Includes thorough JSDoc for all public methods
   - Helpful error messages when runtime/compose are missing
2. Create new file scripts/container-runtime.test.mjs with Vitest tests:
   - Mocks child_process to simulate environments
   - Tests runtime detection, sudo requirement detection, compose command determination, exec command construction, and error cases when no runtime is available
3. No updates to existing files required at this stage. In a future step, replace hardcoded "sudo docker compose ..." with ContainerRuntime usage where referenced in server.mjs (lines 220, 517, 539, 548, 584, 742, 805, 860, 889, 1263, 1291, 1298). For example, replace "sudo docker compose up -d" with runtime.exec(['compose', 'up', '-d']).

<NEWFILE: scripts/container-runtime.mjs>
/**
 * Container runtime abstraction for Docker and Podman.
 *
 * Design goals:
 * - Zero-config: prefers Docker, falls back to Podman
 * - Smart detection: docker vs podman, compose variants, sudo need
 * - Helpful errors when dependencies are missing
 * - Testable: all process execution goes through child_process; easy to mock via Vitest spies
 *
 * Usage:
 *   import { ContainerRuntime } from './container-runtime.mjs';
 *   const rt = new ContainerRuntime();
 *   await rt.exec(['compose', 'up', '-d']);
 *
 * Notes:
 * - exec() prefers array form: ['compose', 'up', '-d'] or ['pull', 'alpine'].
 * - For compose with Podman, this maps to either `podman-compose up -d` or `podman compose up -d`.
 * - For compose with Docker, this maps to `docker compose up -d` or (fallback) `docker-compose up -d`.
 */

import * as cp from 'node:child_process';
import os from 'node:os';
import process from 'node:process';

/**
 * @typedef {'docker' | 'podman'} RuntimeName
 */

/**
 * @typedef {Object} ContainerRuntimeOptions
 * @property {'docker'|'podman'} [preferredRuntime] - Manually prefer a runtime if both exist. If the preferred one is not available, falls back to the other.
 * @property {boolean} [forceSudo] - Force enable/disable sudo. If undefined, auto-detection applies.
 * @property {string} [composeOverride] - Force compose binary string. Examples: 'docker compose', 'docker-compose', 'podman-compose', 'podman compose'
 * @property {Record<string,string>} [env] - Environment variables for spawned processes (defaults to process.env)
 * @property {string} [cwd] - Working directory for exec invocations (defaults to process.cwd())
 * @property {{debug?:Function, info?:Function, warn?:Function, error?:Function}} [logger] - Optional logger (defaults to console). Missing methods are no-ops.
 */

function createLogger(logger) {
  const noop = () => {};
  const base = logger || console;
  return {
    debug: typeof base.debug === 'function' ? base.debug.bind(base) : noop,
    info: typeof base.info === 'function' ? base.info.bind(base) : noop,
    warn: typeof base.warn === 'function' ? base.warn.bind(base) : noop,
    error: typeof base.error === 'function' ? base.error.bind(base) : noop,
  };
}

/**
 * Safe spawnSync wrapper returning a normalized result.
 * @param {string} cmd
 * @param {string[]} args
 * @param {import('node:child_process').SpawnSyncOptions} [options]
 */
function runSync(cmd, args, options) {
  try {
    const res = cp.spawnSync(cmd, args, { stdio: 'pipe', encoding: 'utf8', ...options });
    // Normalize shape
    return {
      status: typeof res.status === 'number' ? res.status : (typeof res.status === 'undefined' && typeof res.signal === 'string' ? 1 : res.status),
      stdout: res.stdout || '',
      stderr: res.stderr || '',
      error: res.error || null,
    };
  } catch (err) {
    return { status: 1, stdout: '', stderr: String(err), error: err };
  }
}

/**
 * Determine if a command exists by attempting to run `cmd --version`.
 * @param {string} cmd
 * @returns {boolean}
 */
function commandExists(cmd) {
  const res = runSync(cmd, ['--version']);
  if (res.error && res.error.code === 'ENOENT') return false;
  return res.status === 0;
}

/**
 * Attempt to parse JSON safely, returning null on error.
 * @param {string} text
 * @returns {any|null}
 */
function tryParseJSON(text) {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}

/**
 * Container runtime abstraction that handles detection and command execution.
 */
export class ContainerRuntime {
  /**
   * @param {ContainerRuntimeOptions} [options]
   */
  constructor(options = {}) {
    this.options = {
      env: options.env || process.env,
      cwd: options.cwd || process.cwd(),
      preferredRuntime: options.preferredRuntime,
      forceSudo: typeof options.forceSudo === 'boolean' ? options.forceSudo : undefined,
      composeOverride: options.composeOverride,
      logger: createLogger(options.logger),
    };

    /** @type {RuntimeName|null} */
    this._runtime = null;
    /** @type {boolean|null} */
    this._needsSudo = null;

    // Compose tool info computed lazily per runtime:
    // Docker: either {kind: 'plugin', cmd: 'docker', subcmd: 'compose'} or {kind: 'v1', cmd: 'docker-compose'}
    // Podman: either {kind: 'podman-compose', cmd: 'podman-compose'} or {kind: 'plugin', cmd: 'podman', subcmd: 'compose'}
    /** @type {{kind: string, cmd: string, subcmd?: string}|null} */
    this._composeTool = null;
  }

  /**
   * Detect and return the container runtime ('docker' or 'podman').
   * Preference: docker first, then podman, unless overridden via options.preferredRuntime.
   * Caches the result.
   * @returns {RuntimeName}
   * @throws {Error} If no runtime is available.
   */
  detectRuntime() {
    if (this._runtime) return /** @type {RuntimeName} */ (this._runtime);

    const { preferredRuntime } = this.options;
    const log = this.options.logger;

    const dockerAvailable = commandExists('docker');
    const podmanAvailable = commandExists('podman');

    log.debug?.(`ContainerRuntime: dockerAvailable=${dockerAvailable}, podmanAvailable=${podmanAvailable}, preferred=${preferredRuntime || 'none'}`);

    /** @type {RuntimeName|null} */
    let chosen = null;

    if (preferredRuntime === 'docker') {
      chosen = dockerAvailable ? 'docker' : (podmanAvailable ? 'podman' : null);
    } else if (preferredRuntime === 'podman') {
      chosen = podmanAvailable ? 'podman' : (dockerAvailable ? 'docker' : null);
    } else {
      // Default: docker first, then podman
      chosen = dockerAvailable ? 'docker' : (podmanAvailable ? 'podman' : null);
    }

    if (!chosen) {
      const err = new Error(
        [
          'No container runtime detected. VibeTrees requires Docker or Podman.',
          'Detection attempted: `docker --version` and `podman --version` on PATH.',
          'Install one of the following and try again:',
          '- Docker: https://docs.docker.com/get-docker/',
          '- Podman: https://podman.io/getting-started/installation',
        ].join('\n')
      );
      err.code = 'NO_RUNTIME';
      throw err;
    }

    this._runtime = chosen;
    return chosen;
  }

  /**
   * Determine whether we need sudo to run the container runtime.
   * Caches the result unless forceSudo is set in options.
   * - Docker: run `docker info`; if fails, try `sudo -n docker info` to check if sudo resolves it.
   * - Podman: check `podman info --format json` rootless flag. If rootless=true -> no sudo. Otherwise, sudo unless running as root.
   * On Windows, sudo is never needed.
   * @returns {boolean}
   */
  needsElevation() {
    if (os.platform() === 'win32') return false; // no sudo on Windows

    if (typeof this.options.forceSudo === 'boolean') {
      return this.options.forceSudo;
    }

    if (this._needsSudo !== null) {
      return /** @type {boolean} */ (this._needsSudo);
    }

    const runtime = this.detectRuntime();
    const log = this.options.logger;

    if (runtime === 'docker') {
      const res = runSync('docker', ['info']);
      if (res.status === 0) {
        this._needsSudo = false;
        return false;
      }
      // Try non-interactive sudo check
      const sudoCheck = runSync('sudo', ['-n', 'docker', 'info']);
      log.debug?.(`Docker info without sudo status=${res.status}, with sudo -n status=${sudoCheck.status}`);
      if (sudoCheck.status === 0) {
        this._needsSudo = true;
        return true;
      }
      // Default to true if non-root and docker info fails (common case: needs sudo), but warn
      this._needsSudo = true;
      log.warn?.('Docker may require sudo but `sudo -n` failed. Execution may prompt for a password.');
      return true;
    }

    // Podman
    const info = runSync('podman', ['info', '--format', 'json']);
    let rootless = null;
    if (info.status === 0) {
      const parsed = tryParseJSON(info.stdout);
      rootless = parsed && parsed.host && parsed.host.security ? Boolean(parsed.host.security.rootless) : null;
    }
    if (rootless === true) {
      this._needsSudo = false;
      return false;
    }
    // If not rootless, assume sudo if not running as root
    const isRoot = typeof process.getuid === 'function' ? process.getuid() === 0 : false;
    this._needsSudo = !isRoot;
    return this._needsSudo;
  }

  /**
   * Determine the compose command string for the selected runtime:
   * - For docker: returns 'docker compose' or fallback 'docker-compose' if plugin missing.
   * - For podman: returns 'podman-compose' or fallback 'podman compose' if the python tool is missing but plugin works.
   * Caches the result.
   * @returns {string}
   * @throws {Error} If no compose tool is available for the chosen runtime.
   */
  getComposeCommand() {
    const runtime = this.detectRuntime();

    // Manual override
    if (typeof this.options.composeOverride === 'string' && this.options.composeOverride.trim().length > 0) {
      return this.options.composeOverride.trim();
    }

    if (this._composeTool) {
      return this._composeTool.subcmd ? `${this._composeTool.cmd} ${this._composeTool.subcmd}` : this._composeTool.cmd;
    }

    if (runtime === 'docker') {
      // Prefer plugin: docker compose
      const hasPlugin = runSync('docker', ['compose', 'version']).status === 0;
      if (hasPlugin) {
        this._composeTool = { kind: 'plugin', cmd: 'docker', subcmd: 'compose' };
        return 'docker compose';
      }
      // Fallback to v1: docker-compose
      const v1 = commandExists('docker-compose');
      if (v1) {
        this._composeTool = { kind: 'v1', cmd: 'docker-compose' };
        return 'docker-compose';
      }
      const err = new Error(
        [
          'Docker Compose not found.',
          'Tried both `docker compose` (plugin) and `docker-compose` (v1).',
          'Install the Docker Compose plugin (v2) or the docker-compose v1 binary.',
          'Docs: https://docs.docker.com/compose/',
        ].join('\n')
      );
      err.code = 'NO_COMPOSE';
      throw err;
    }

    // Podman
    // Prefer podman-compose (python tool)
    const hasPodmanCompose = commandExists('podman-compose');
    if (hasPodmanCompose) {
      this._composeTool = { kind: 'podman-compose', cmd: 'podman-compose' };
      return 'podman-compose';
    }
    // Fallback to plugin: podman compose (available in newer Podman)
    const pluginOk = runSync('podman', ['compose', 'version']).status === 0
      || runSync('podman', ['compose', '--help']).status === 0; // some versions don't support version subcmd
    if (pluginOk) {
      this._composeTool = { kind: 'plugin', cmd: 'podman', subcmd: 'compose' };
      return 'podman compose';
    }
    const err = new Error(
      [
        'Podman Compose not found.',
        'Tried both `podman-compose` and `podman compose`.',
        'Install podman-compose: https://github.com/containers/podman-compose',
        'or ensure your Podman version supports `podman compose`.',
      ].join('\n')
    );
    err.code = 'NO_COMPOSE';
    throw err;
  }

  /**
   * Execute a container runtime command with correct binary mapping and sudo if needed.
   *
   * Recommended: pass command as an array for precise mapping and argument handling.
   *
   * Examples:
   *   await runtime.exec(['compose', 'up', '-d']);
   *   await runtime.exec(['pull', 'alpine']);
   *
   * String commands are supported but less safe (shell parsing, quoting). Arrays are preferred.
   *
   * @param {string[]|string} command - If array:
   *   - When first element is 'compose', it maps to the appropriate compose tool for the runtime.
   *   - Otherwise treated as direct subcommands to the runtime ('docker' or 'podman').
   *   If string: executed via shell after applying runtime/compose mapping heuristics.
   * @param {import('node:child_process').SpawnOptions} [options] - spawn options override (cwd/env default to constructor options).
   * @returns {Promise<void>} Resolves on exit code 0; rejects with Error on non-zero exit.
   */
  async exec(command, options = {}) {
    const runtime = this.detectRuntime();
    const needsSudo = this.needsElevation();
    const composeStr = this._ensureComposeResolvedIfNeeded(command);
    const log = this.options.logger;

    /** @type {string} */
    let bin;
    /** @type {string[]} */
    let args;

    if (Array.isArray(command)) {
      const [first, ...rest] = command;
      if (first === 'compose') {
        const tool = this._composeTool || this._resolveComposeTool();
        if (tool.subcmd) {
          // plugin form like: docker compose ... OR podman compose ...
          bin = tool.cmd;
          args = [tool.subcmd, ...rest];
        } else {
          // standalone binary like docker-compose or podman-compose
          bin = tool.cmd;
          args = rest;
        }
      } else {
        // normal docker/podman subcommands
        bin = runtime;
        args = [first, ...rest];
      }
    } else if (typeof command === 'string') {
      // Heuristic mapping for string form
      const trimmed = command.trim();
      const isCompose = /^compose(\s|$)/.test(trimmed);
      const tool = isCompose ? (this._composeTool || this._resolveComposeTool()) : null;

      if (isCompose && tool) {
        if (tool.subcmd) {
          bin = tool.cmd;
          args = [tool.subcmd, ...splitShellWords(trimmed.replace(/^compose\s*/, ''))];
        } else {
          bin = tool.cmd;
          args = splitShellWords(trimmed.replace(/^compose\s*/, ''));
        }
      } else {
        bin = runtime;
        args = splitShellWords(trimmed);
      }
    } else {
      throw new TypeError('Invalid command type; expected string or string[]');
    }

    // Prepend sudo if needed (and not Windows)
    const isWin = os.platform() === 'win32';
    let finalBin = bin;
    let finalArgs = args;
    if (!isWin && needsSudo) {
      finalBin = 'sudo';
      finalArgs = [bin, ...args];
    }

    const spawnOpts = {
      cwd: this.options.cwd,
      env: this.options.env,
      stdio: 'inherit',
      ...options,
    };

    log.debug?.(`Executing: ${finalBin} ${finalArgs.join(' ')}`);

    const child = cp.spawn(finalBin, finalArgs, spawnOpts);

    // Return a Promise that resolves on success (code 0) or rejects otherwise
    return new Promise((resolve, reject) => {
      child.on('error', (err) => {
        const wrapped = new Error(`Failed to spawn process: ${finalBin} ${finalArgs.join(' ')}\n${err?.message || String(err)}`);
        wrapped.cause = err;
        reject(wrapped);
      });
      child.on('close', (code, signal) => {
        if (code === 0) {
          resolve();
        } else {
          const err = new Error(`Command exited with code ${code}: ${finalBin} ${finalArgs.join(' ')}`);
          err.code = code;
          err.signal = signal;
          reject(err);
        }
      });
    });
  }

  /**
   * Internal: resolve and cache compose tool for current runtime.
   * @returns {{kind: string, cmd: string, subcmd?: string}}
   * @private
   */
  _resolveComposeTool() {
    // This calls getComposeCommand() which will fill _composeTool
    this.getComposeCommand();
    // now guaranteed
    return /** @type {{kind: string, cmd: string, subcmd?: string}} */ (this._composeTool);
  }

  /**
   * Internal: ensure compose tool is resolved when the command needs it.
   * @param {string[]|string} command
   * @returns {string|null} The resolved compose string (e.g., "docker compose" or "podman-compose"), or null if not compose.
   * @private
   */
  _ensureComposeResolvedIfNeeded(command) {
    if (Array.isArray(command)) {
      if (command[0] === 'compose') {
        return this.getComposeCommand();
      }
      return null;
    }
    if (typeof command === 'string') {
      const trimmed = command.trim();
      if (/^compose(\s|$)/.test(trimmed)) {
        return this.getComposeCommand();
      }
      return null;
    }
    return null;
  }
}

/**
 * Split a shell-like string into argv parts.
 * This is a minimal splitter; for reliable behavior pass arrays to exec().
 * @param {string} s
 * @returns {string[]}
 */
function splitShellWords(s) {
  // Minimal implementation: split on whitespace respecting simple quotes
  const out = [];
  let cur = '';
  let quote = null; // "'" or '"'
  for (let i = 0; i < s.length; i += 1) {
    const ch = s[i];
    if (quote) {
      if (ch === quote) {
        quote = null;
      } else {
        cur += ch;
      }
    } else {
      if (ch === '"' || ch === "'") {
        quote = ch;
      } else if (/\s/.test(ch)) {
        if (cur) {
          out.push(cur);
          cur = '';
        }
      } else {
        cur += ch;
      }
    }
  }
  if (cur) out.push(cur);
  return out;
}
</NEWFILE>

<NEWFILE: scripts/container-runtime.test.mjs>
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import * as cp from 'node:child_process';
import { ContainerRuntime } from './container-runtime.mjs';

// Helper to build a controlled spawnSync mock
function makeSpawnSyncMock(map) {
  // Map keys: command + ' ' + args.join(' ')
  // value: { status, stdout, stderr, error }
  return vi.fn((cmd, args) => {
    const key = [cmd, ...(Array.isArray(args) ? args : [])].join(' ').trim();
    const value = map[key];
    if (!value) {
      // default: ENOENT (not found)
      return {
        status: 1,
        stdout: '',
        stderr: `command not found: ${key}`,
        error: Object.assign(new Error(`ENOENT: ${key}`), { code: 'ENOENT' }),
      };
    }
    // Provide defaults
    return {
      status: typeof value.status === 'number' ? value.status : 0,
      stdout: value.stdout || '',
      stderr: value.stderr || '',
      error: value.error || null,
    };
  });
}

// Simple spawn mock that captures args and simulates success by default
function makeSpawnMock({ exitCode = 0 } = {}) {
  return vi.fn((cmd, args, opts) => {
    // minimal event emitter
    const listeners = {};
    const child = {
      pid: 12345,
      stdout: null,
      stderr: null,
      on: (event, cb) => {
        listeners[event] = listeners[event] || [];
        listeners[event].push(cb);
        return child;
      },
      emit: (event, ...evArgs) => {
        (listeners[event] || []).forEach((cb) => cb(...evArgs));
      },
    };
    // async simulate
    setTimeout(() => {
      child.emit('close', exitCode, null);
    }, 0);
    return child;
  });
}

describe('ContainerRuntime detection', () => {
  let spawnSyncMock;
  let spawnMock;

  beforeEach(() => {
    vi.restoreAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('detects docker when available, and compose plugin, and no sudo needed', () => {
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 0, stdout: 'Docker version 26.0.0' },
      'podman --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },

      'docker compose version': { status: 0, stdout: 'Docker Compose version v2.27.0' },
      'docker info': { status: 0, stdout: '{}' },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);

    const rt = new ContainerRuntime();
    expect(rt.detectRuntime()).toBe('docker');
    expect(rt.getComposeCommand()).toBe('docker compose');
    expect(rt.needsElevation()).toBe(false);
  });

  it('falls back to podman when docker is unavailable and detects rootless (no sudo)', () => {
    const podmanInfo = JSON.stringify({ host: { security: { rootless: true } } });
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },
      'podman --version': { status: 0, stdout: 'podman version 4.9.0' },

      'podman info --format json': { status: 0, stdout: podmanInfo },
      'podman-compose --version': { status: 0, stdout: 'podman-compose version 1.0.0' },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);

    const rt = new ContainerRuntime();
    expect(rt.detectRuntime()).toBe('podman');
    expect(rt.getComposeCommand()).toBe('podman-compose');
    expect(rt.needsElevation()).toBe(false);
  });

  it('docker detected but requires sudo (docker info fails, sudo -n succeeds)', () => {
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 0, stdout: 'Docker version' },
      'podman --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },

      'docker compose version': { status: 0, stdout: 'Docker Compose v2' },
      'docker info': { status: 1, stderr: 'permission denied' },
      'sudo -n docker info': { status: 0, stdout: '{}' },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);

    const rt = new ContainerRuntime();
    expect(rt.detectRuntime()).toBe('docker');
    expect(rt.needsElevation()).toBe(true);
  });

  it('docker compose plugin missing but docker-compose v1 available', () => {
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 0, stdout: 'Docker version' },
      'podman --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },

      'docker compose version': { status: 1, stderr: 'unknown command compose' },
      'docker-compose --version': { status: 0, stdout: 'docker-compose version 1.29.2' },
      'docker info': { status: 0, stdout: '{}' },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);

    const rt = new ContainerRuntime();
    expect(rt.detectRuntime()).toBe('docker');
    expect(rt.getComposeCommand()).toBe('docker-compose');
  });

  it('throws helpful error when no runtime available', () => {
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },
      'podman --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);

    const rt = new ContainerRuntime();
    expect(() => rt.detectRuntime()).toThrow(/No container runtime detected/);
  });
});

describe('ContainerRuntime exec command construction', () => {
  let spawnSyncMock;
  let spawnMock;

  beforeEach(() => {
    vi.restoreAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('exec constructs docker compose with sudo when needed', async () => {
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 0 },
      'podman --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },

      'docker compose version': { status: 0 },
      'docker info': { status: 1, stderr: 'permission denied' },
      'sudo -n docker info': { status: 0 },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);

    spawnMock = makeSpawnMock({ exitCode: 0 });
    const spawnSpy = vi.spyOn(cp, 'spawn').mockImplementation(spawnMock);

    const rt = new ContainerRuntime();
    await rt.exec(['compose', 'up', '-d']);

    // Should invoke: sudo docker compose up -d
    expect(spawnSpy).toHaveBeenCalled();
    const call = spawnSpy.mock.calls[0];
    expect(call[0]).toBe('sudo');
    expect(call[1]).toEqual(['docker', 'compose', 'up', '-d']);
  });

  it('exec constructs docker compose without sudo when not needed', async () => {
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 0 },
      'podman --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },

      'docker compose version': { status: 0 },
      'docker info': { status: 0 },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);
    const spawnSpy = vi.spyOn(cp, 'spawn').mockImplementation(makeSpawnMock({ exitCode: 0 }));

    const rt = new ContainerRuntime();
    await rt.exec(['compose', 'up', '-d']);

    expect(spawnSpy).toHaveBeenCalled();
    const call = spawnSpy.mock.calls[0];
    expect(call[0]).toBe('docker');
    expect(call[1]).toEqual(['compose', 'up', '-d']);
  });

  it('exec constructs podman-compose up -d (no sudo, rootless)', async () => {
    const podmanInfo = JSON.stringify({ host: { security: { rootless: true } } });
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },
      'podman --version': { status: 0 },

      'podman info --format json': { status: 0, stdout: podmanInfo },
      'podman-compose --version': { status: 0 },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);
    const spawnSpy = vi.spyOn(cp, 'spawn').mockImplementation(makeSpawnMock({ exitCode: 0 }));

    const rt = new ContainerRuntime();
    await rt.exec(['compose', 'up', '-d']);

    expect(spawnSpy).toHaveBeenCalled();
    const call = spawnSpy.mock.calls[0];
    expect(call[0]).toBe('podman-compose');
    expect(call[1]).toEqual(['up', '-d']);
  });

  it('exec constructs podman compose up -d when podman-compose is absent', async () => {
    const podmanInfo = JSON.stringify({ host: { security: { rootless: true } } });
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },
      'podman --version': { status: 0 },

      'podman info --format json': { status: 0, stdout: podmanInfo },
      'podman-compose --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },
      'podman compose version': { status: 0 },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);
    const spawnSpy = vi.spyOn(cp, 'spawn').mockImplementation(makeSpawnMock({ exitCode: 0 }));

    const rt = new ContainerRuntime();
    await rt.exec(['compose', 'up', '-d']);

    expect(spawnSpy).toHaveBeenCalled();
    const call = spawnSpy.mock.calls[0];
    expect(call[0]).toBe('podman');
    expect(call[1]).toEqual(['compose', 'up', '-d']);
  });

  it('exec constructs podman-compose with sudo when not rootless', async () => {
    const podmanInfo = JSON.stringify({ host: { security: { rootless: false } } });
    spawnSyncMock = makeSpawnSyncMock({
      'docker --version': { status: 1, error: Object.assign(new Error('ENOENT'), { code: 'ENOENT' }) },
      'podman --version': { status: 0 },

      'podman info --format json': { status: 0, stdout: podmanInfo },
      'podman-compose --version': { status: 0 },
    });
    vi.spyOn(cp, 'spawnSync').mockImplementation(spawnSyncMock);
    const spawnSpy = vi.spyOn(cp, 'spawn').mockImplementation(makeSpawnMock({ exitCode: 0 }));

    const rt = new ContainerRuntime();
    await rt.exec(['compose', 'up', '-d']);

    expect(spawnSpy).toHaveBeenCalled();
    const call = spawnSpy.mock.calls[0];
    expect(call[0]).toBe('sudo');
    expect(call[1]).toEqual(['podman-compose', 'up', '-d']);
  });
});
</NEWFILE>
</GENERATED-CODE>
